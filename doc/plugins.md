# Plugin System Documentation

## Overview

The ROS Speckle Bridge uses a plugin architecture to extend functionality without adding dependencies to the core package. Plugins process BIM objects after they are fetched and converted, enabling integration with simulators, exporters, and custom workflows.

## Architecture

```
┌─────────────────────────┐
│  SpeckleBridgeNode      │
│  - Fetches BIM data     │
│  - Converts to ROS msgs │
└──────────┬──────────────┘
           │
           │ notify_objects_received()
           │
           ▼
┌─────────────────────────┐
│   PluginLoader          │
│  - Loads plugins        │
│  - Manages lifecycle    │
└──────────┬──────────────┘
           │
           │ on_objects_received()
           │
    ┌──────┴──────┬──────────┬──────────┐
    ▼             ▼          ▼          ▼
┌────────┐  ┌──────────┐  ┌─────┐  ┌──────┐
│ Mesh   │  │ Gazebo   │  │ ... │  │Custom│
│Exporter│  │ Spawner  │  │     │  │Plugin│
└────────┘  └──────────┘  └─────┘  └──────┘
```

## Plugin Interface

All plugins must inherit from `OutputPlugin`:

```python
from ros_speckle_bridge.plugins.base import OutputPlugin
from typing import List, Dict, Any
from bim_interfaces.msg import BimObject

class MyPlugin(OutputPlugin):
    def __init__(self, node):
        super().__init__(node)
        # Initialize plugin-specific state
    
    def initialize(self, config: Dict[str, Any]) -> bool:
        """Called once at startup with plugin configuration"""
        # Setup resources, validate config
        return True  # Return False if initialization fails
    
    def on_objects_received(self, objects: List[BimObject]) -> None:
        """Called when new BIM objects are received"""
        # Process objects (export, spawn, log, etc.)
        pass
    
    def get_plugin_name(self) -> str:
        """Return plugin name for logging"""
        return "my_plugin"
    
    def shutdown(self) -> None:
        """Called when node is shutting down"""
        # Cleanup resources
        pass
```

## Configuration

Plugins are configured via ROS parameters in YAML format.

### Syntax

```yaml
/**:
  ros__parameters:
    plugins:
      - type: "<plugin_identifier>"
        enabled: true|false
        config:
          <plugin_specific_config>
```

### Loading Methods

1. **Built-in Plugin (Short Name)**
   ```yaml
   - type: "mesh_exporter"
     enabled: true
   ```
   Looks for: `ros_speckle_bridge.plugins.mesh_exporter`

2. **File Path**
   ```yaml
   - type: "/absolute/path/to/plugin.py:ClassName"
     enabled: true
   ```
   Loads plugin class directly from a file. Useful for development.

3. **Module Path**
   ```yaml
   - type: "package.module.ClassName"
     enabled: true
   ```
   Imports from an installed Python package. Best for production.

## Built-in Plugins

### mesh_exporter

Exports BIM geometry to mesh files (Collada, OBJ, STL).

```yaml
- type: "mesh_exporter"
  enabled: true
  config:
    output_path: "/shared_meshes"  # Required
    format: "dae"                  # dae (Gazebo), obj, stl, usd
    export_metadata: true          # Export JSON metadata sidecar
```

**Outputs:**
- `{output_path}/{object_uuid}.{format}` - Mesh file
- `{output_path}/{object_uuid}.json` - Metadata (if enabled)

## Example Plugins

### gazebo_spawner (Gazebo Harmonic)

Spawns entities in Gazebo simulation using the `ros_gz_interfaces`.

```yaml
- type: "/path/to/ros_speckle_gazebo/gazebo_spawner.py:GazeboSpawnerPlugin"
  enabled: true
  config:
    spawn_service: "/world/default/create"
    mesh_path: "/shared_meshes"
    frame_id: "world"
    default_physics:
      static: false
      mass: 100.0
      friction: 0.8
      restitution: 0.3
```

**Requirements:**
- `ros-humble-ros-gz-interfaces`
- Gazebo Harmonic running
- Mesh files available in `mesh_path` (usually generated by `mesh_exporter`)
   - Auto-discovers `OutputPlugin` subclass

2. **File Path** (`/path/to/plugin.py:ClassName`):
   - Loads Python file and imports specified class
   - Useful for custom external plugins

3. **Qualified Path** (`package.module.ClassName`):
   - Standard Python import path
   - Plugin must be in Python path

## Built-in Plugins

### Mesh Exporter

Exports BIM geometry to mesh files (OBJ, DAE, STL).

**Configuration:**
```yaml
- type: mesh_exporter
  enabled: true
  config:
    output_path: /shared_meshes
    format: dae  # obj, dae, stl
    export_metadata: true
```

## Creating Custom Plugins

### 1. Create Plugin File

```python
# my_plugin.py
from ros_speckle_bridge.plugins.base import OutputPlugin
from typing import List, Dict, Any
from bim_interfaces.msg import BimObject

class MyPlugin(OutputPlugin):
    def __init__(self, node):
        super().__init__(node)
        self.output_dir = None
    
    def initialize(self, config: Dict[str, Any]) -> bool:
        self.output_dir = config.get('output_dir', '/tmp')
        self.node.get_logger().info(f"MyPlugin: Output dir = {self.output_dir}")
        return True
    
    def on_objects_received(self, objects: List[BimObject]) -> None:
        self.node.get_logger().info(f"Processing {len(objects)} objects")
        for obj in objects:
            # Your processing logic here
            self.node.get_logger().debug(f"Processing {obj.element_id}")
    
    def get_plugin_name(self) -> str:
        return "my_plugin"
    
    def shutdown(self) -> None:
        self.node.get_logger().info("MyPlugin shutting down")
```

### 2. Add to Configuration

```yaml
plugins:
  - type: /path/to/my_plugin.py:MyPlugin
    enabled: true
    config:
      output_dir: /my/output
```

### 3. Best Practices

- **Error Handling**: Wrap processing in try-except, don't crash the bridge
- **Logging**: Use `self.node.get_logger()` for consistent logging
- **Resources**: Clean up in `shutdown()` method
- **Configuration**: Validate config in `initialize()`, return False on error
- **Performance**: Avoid blocking operations in `on_objects_received()`

## Example: Database Logger Plugin

```python
from ros_speckle_bridge.plugins.base import OutputPlugin
import sqlite3

class DatabaseLoggerPlugin(OutputPlugin):
    def __init__(self, node):
        super().__init__(node)
        self.conn = None
    
    def initialize(self, config):
        db_path = config.get('database', 'bim_objects.db')
        self.conn = sqlite3.connect(db_path)
        self.conn.execute('''
            CREATE TABLE IF NOT EXISTS objects (
                id TEXT PRIMARY KEY,
                category TEXT,
                timestamp REAL
            )
        ''')
        return True
    
    def on_objects_received(self, objects):
        import time
        timestamp = time.time()
        
        for obj in objects:
            self.conn.execute(
                'INSERT OR REPLACE INTO objects VALUES (?, ?, ?)',
                (obj.element_id, obj.category, timestamp)
            )
        self.conn.commit()
        self.node.get_logger().info(f"Logged {len(objects)} objects to database")
    
    def get_plugin_name(self):
        return "database_logger"
    
    def shutdown(self):
        if self.conn:
            self.conn.close()
```

## Debugging Plugins

### Enable Debug Logging

```bash
ros2 run ros_speckle_bridge bridge_node --ros-args --log-level debug
```

### Common Issues

1. **Plugin not loading**: Check `type` field matches plugin name/path
2. **Import errors**: Ensure plugin file is accessible and has correct class name
3. **Initialization fails**: Check config parameters and return values
4. **Silent failures**: Add logging to your plugin methods

## Advanced: Plugin Communication

Plugins can access the ROS node to create publishers, subscribers, or services:

```python
class InteractivePlugin(OutputPlugin):
    def initialize(self, config):
        # Create a service
        self.srv = self.node.create_service(
            MyService, 
            '/my_plugin/command', 
            self.handle_command
        )
        
        # Create a publisher
        self.pub = self.node.create_publisher(
            MyMsg, 
            '/my_plugin/output', 
            10
        )
        return True
    
    def handle_command(self, request, response):
        # Handle service call
        return response
```

## Plugin Lifecycle

1. **Load**: PluginLoader imports plugin class
2. **Instantiate**: Plugin `__init__()` called with node reference
3. **Initialize**: `initialize(config)` called with plugin config
4. **Process**: `on_objects_received()` called when data arrives
5. **Shutdown**: `shutdown()` called when node terminates

## See Also

- [Plugin Development Guide](extending.md)
- [Gazebo Integration Example](../examples/gazebo_integration/README.md)
- [Base Plugin API](../ros_speckle_bridge/ros_speckle_bridge/plugins/base.py)
